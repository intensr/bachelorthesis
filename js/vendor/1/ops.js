var Ops=Ops||{};Ops.Ui=Ops.Ui||{},Ops.Gl=Ops.Gl||{},Ops.Math=Ops.Math||{},Ops.Anim=Ops.Anim||{},Ops.Devices=Ops.Devices||{},Ops.Gl.Phong=Ops.Gl.Phong||{},Ops.Gl.Shader=Ops.Gl.Shader||{},Ops.Gl.Meshes=Ops.Gl.Meshes||{},Ops.Gl.Matrix=Ops.Gl.Matrix||{},Ops.Deprecated=Ops.Deprecated||{},Ops.Deprecated.Gl=Ops.Deprecated.Gl||{},Ops.Devices.Mouse=Ops.Devices.Mouse||{},Ops.Gl.TextureEffects=Ops.Gl.TextureEffects||{},Ops.Deprecated.Gl.Matrix=Ops.Deprecated.Gl.Matrix||{},Ops.Deprecated.Gl.TextureEffects=Ops.Deprecated.Gl.TextureEffects||{},Ops.Gl.Shader.BasicMaterial=function(){function e(){s.setShader(l),l.bindTextures(),c.get()?s.gl.blendFunc(s.gl.ONE,s.gl.ONE_MINUS_SRC_ALPHA):s.gl.blendFunc(s.gl.SRC_ALPHA,s.gl.ONE_MINUS_SRC_ALPHA),i.trigger(),c.get()&&s.gl.blendFunc(s.gl.SRC_ALPHA,s.gl.ONE_MINUS_SRC_ALPHA),s.setPreviousShader()}function t(){1!=T.get()||1!=P.get()||0!=m.get()||0!=h.get()?(l.define("TEXTURE_REPEAT"),p||(p=new CGL.Uniform(l,"f","diffuseRepeatX",P),v=new CGL.Uniform(l,"f","diffuseRepeatY",T),E=new CGL.Uniform(l,"f","texOffsetX",h),_=new CGL.Uniform(l,"f","texOffsetY",m))):l.removeDefine("TEXTURE_REPEAT")}Op.apply(this,arguments);var n=this,r={};r.shader_frag="precision highp float;\n\n\n{{MODULES_HEAD}}\n\n#ifdef HAS_TEXTURES\n   varying vec2 texCoord;\n   #ifdef HAS_TEXTURE_DIFFUSE\n       uniform sampler2D tex;\n   #endif\n   #ifdef HAS_TEXTURE_OPACITY\n       uniform sampler2D texOpacity;\n   #endif\n#endif\nuniform float r;\nuniform float g;\nuniform float b;\nuniform float a;\n\nvoid main()\n{\n\n#ifdef HAS_TEXTURES\n   vec2 texCoords=texCoord;\n#endif\n\n{{MODULE_BEGIN_FRAG}}\n\n\n   vec4 col=vec4(r,g,b,a);\n   #ifdef HAS_TEXTURES\n      #ifdef HAS_TEXTURE_DIFFUSE\n\n           col=texture2D(tex,vec2(texCoord.x,(1.0-texCoord.y)));\n\n//         col=texture2D(tex,vec2(texCoords.x*1.0,(1.0-texCoords.y)*1.0));\n           #ifdef COLORIZE_TEXTURE\n               col.r*=r;\n               col.g*=g;\n               col.b*=b;\n           #endif\n      #endif\n      #ifdef HAS_TEXTURE_OPACITY\n          col.a*=texture2D(texOpacity,texCoords).g;\n       #endif\n       col.a*=a;\n   #endif\n{{MODULE_COLOR}}\n\n   gl_FragColor = col;\n}\n",r.shader_vert="{{MODULES_HEAD}}\nattribute vec3 vPosition;\nattribute vec2 attrTexCoord;\n\nvarying vec3 norm;\n#ifdef HAS_TEXTURES\n    varying vec2 texCoord;\n    #ifdef TEXTURE_REPEAT\n        uniform float diffuseRepeatX;\n        uniform float diffuseRepeatY;\n        uniform float texOffsetX;\n        uniform float texOffsetY;\n\n    #endif\n#endif\n\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\n\nvoid main()\n{\n    #ifdef HAS_TEXTURES\n        texCoord=attrTexCoord;\n        #ifdef TEXTURE_REPEAT\n            texCoord.s=texCoord.s*diffuseRepeatX+texOffsetX;\n            texCoord.t=texCoord.t*diffuseRepeatY+texOffsetY;\n        #endif\n   #endif\n\n   vec4 pos = vec4( vPosition, 1. );\n\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mat4 mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n    #ifndef BILLBOARD\n        mat4 mvMatrix=viewMatrix * modelMatrix;\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n",n.name="BasicMaterial";var o=n.addInPort(new Port(n,"render",OP_PORT_TYPE_FUNCTION)),i=n.addOutPort(new Port(n,"trigger",OP_PORT_TYPE_FUNCTION)),a=n.addOutPort(new Port(n,"shader",OP_PORT_TYPE_OBJECT));a.ignoreValueSerialize=!0;var s=n.patch.cgl;n.bindTextures=function(){n.texture.get()?(s.gl.activeTexture(s.gl.TEXTURE0),s.gl.bindTexture(s.gl.TEXTURE_2D,n.texture.get().tex)):(s.gl.activeTexture(s.gl.TEXTURE0),s.gl.bindTexture(s.gl.TEXTURE_2D,null)),n.textureOpacity.get()?(s.gl.activeTexture(s.gl.TEXTURE1),s.gl.bindTexture(s.gl.TEXTURE_2D,n.textureOpacity.get().tex)):(s.gl.activeTexture(s.gl.TEXTURE1),s.gl.bindTexture(s.gl.TEXTURE_2D,null))};var l=new CGL.Shader(s,"BasicMaterial");l.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]),l.bindTextures=n.bindTextures,a.set(l),n.onLoaded=l.compile,l.setSource(r.shader_vert,r.shader_frag);var d=n.addInPort(new Port(n,"r",OP_PORT_TYPE_VALUE,{display:"range",colorPick:"true"}));d.set(Math.random()),d.uniform=new CGL.Uniform(l,"f","r",d);var f=n.addInPort(new Port(n,"g",OP_PORT_TYPE_VALUE,{display:"range"}));f.set(Math.random()),f.uniform=new CGL.Uniform(l,"f","g",f);var u=n.addInPort(new Port(n,"b",OP_PORT_TYPE_VALUE,{display:"range"}));u.set(Math.random()),d.uniform=new CGL.Uniform(l,"f","b",u);var g=n.addInPort(new Port(n,"a",OP_PORT_TYPE_VALUE,{display:"range"}));g.uniform=new CGL.Uniform(l,"f","a",g),g.set(1),o.onTriggered=e,n.texture=n.addInPort(new Port(n,"texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),n.textureUniform=null,n.texture.onValueChanged=function(){if(n.texture.get()){if(null!==n.textureUniform)return;l.removeUniform("tex"),l.define("HAS_TEXTURE_DIFFUSE"),n.textureUniform=new CGL.Uniform(l,"t","tex",0)}else l.removeUniform("tex"),l.removeDefine("HAS_TEXTURE_DIFFUSE"),n.textureUniform=null},n.textureOpacity=n.addInPort(new Port(n,"textureOpacity",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),n.textureOpacityUniform=null,n.textureOpacity.onPreviewChanged=function(){n.textureOpacity.showPreview?o.onTriggered=n.textureOpacity.get().preview:o.onTriggered=e,console.log("show preview!")},n.textureOpacity.onValueChanged=function(){if(n.textureOpacity.get()){if(null!==n.textureOpacityUniform)return;console.log("TEXTURE OPACITY ADDED"),l.removeUniform("texOpacity"),l.define("HAS_TEXTURE_OPACITY"),n.textureOpacityUniform=new CGL.Uniform(l,"t","texOpacity",1)}else console.log("TEXTURE OPACITY REMOVED"),l.removeUniform("texOpacity"),l.removeDefine("HAS_TEXTURE_OPACITY"),n.textureOpacityUniform=null},n.colorizeTexture=n.addInPort(new Port(n,"colorizeTexture",OP_PORT_TYPE_VALUE,{display:"bool"})),n.colorizeTexture.set(!1),n.colorizeTexture.onValueChanged=function(){n.colorizeTexture.get()?l.define("COLORIZE_TEXTURE"):l.removeDefine("COLORIZE_TEXTURE")},n.doBillboard=n.addInPort(new Port(n,"billboard",OP_PORT_TYPE_VALUE,{display:"bool"})),n.doBillboard.set(!1),n.doBillboard.onValueChanged=function(){n.doBillboard.get()?l.define("BILLBOARD"):l.removeDefine("BILLBOARD")};var c=n.addInPort(new Port(n,"preMultiplied alpha",OP_PORT_TYPE_VALUE,{display:"bool"})),P=n.addInPort(new Port(n,"diffuseRepeatX",OP_PORT_TYPE_VALUE)),T=n.addInPort(new Port(n,"diffuseRepeatY",OP_PORT_TYPE_VALUE));P.set(1),T.set(1),P.onValueChanged=t,T.onValueChanged=t;var h=n.addInPort(new Port(n,"Tex Offset X",OP_PORT_TYPE_VALUE)),m=n.addInPort(new Port(n,"Tex Offset Y",OP_PORT_TYPE_VALUE));h.set(0),m.set(0),m.onValueChanged=t,h.onValueChanged=t;var p=null,v=null,E=null,_=null},Ops.Gl.Shader.BasicMaterial.prototype=new CABLES.Op,Ops.Gl.TextureEffects.DrawImage=function(){function e(){(1!=E.get()||0!=_.get()||0!=O.get()||0!=x.get())&&(T.hasDefine("TEX_TRANSFORM")||T.define("TEX_TRANSFORM"),C.setValue(parseFloat(E.get())),R.setValue(_.get()),w.setValue(O.get()),L.setValue(x.get()))}function t(){P.currentTextureEffect&&(s.get()&&s.get().tex&&(P.setShader(T),P.currentTextureEffect.bind(),P.gl.activeTexture(P.gl.TEXTURE0),P.gl.bindTexture(P.gl.TEXTURE_2D,P.currentTextureEffect.getCurrentSourceTexture().tex),P.gl.activeTexture(P.gl.TEXTURE1),P.gl.bindTexture(P.gl.TEXTURE_2D,s.get().tex),d.get()&&d.get().tex&&(P.gl.activeTexture(P.gl.TEXTURE2),P.gl.bindTexture(P.gl.TEXTURE_2D,d.get().tex)),P.currentTextureEffect.finish(),P.setPreviousShader()),c.trigger())}function n(){t(),s.get().preview()}function r(){t(),d.get().preview()}Op.apply(this,arguments);var o=this;o.name="DrawImage";var i=o.addInPort(new Port(o,"render",OP_PORT_TYPE_FUNCTION)),a=o.addInPort(new Port(o,"amount",OP_PORT_TYPE_VALUE,{display:"range"})),s=o.addInPort(new Port(o,"image",OP_PORT_TYPE_TEXTURE,{preview:!0})),l=CGL.TextureEffect.AddBlendSelect(o,"blendMode"),d=o.addInPort(new Port(o,"imageAlpha",OP_PORT_TYPE_TEXTURE,{preview:!0})),f=o.inValueSelect("alphaSrc",["alpha channel","luminance"]),u=o.addInPort(new Port(o,"removeAlphaSrc",OP_PORT_TYPE_VALUE,{display:"bool"})),g=o.addInPort(new Port(o,"invert alpha channel",OP_PORT_TYPE_VALUE,{display:"bool"})),c=o.addOutPort(new Port(o,"trigger",OP_PORT_TYPE_FUNCTION));l.set("normal");var P=o.patch.cgl,T=new CGL.Shader(P,"drawimage");o.onLoaded=T.compile,a.set(1);var h="".endl()+"attribute vec3 vPosition;".endl()+"attribute vec2 attrTexCoord;".endl()+"attribute vec3 attrVertNormal;".endl()+"varying vec2 texCoord;".endl()+"varying vec3 norm;".endl()+"uniform mat4 projMatrix;".endl()+"uniform mat4 mvMatrix;".endl()+"uniform float posX;".endl()+"uniform float posY;".endl()+"uniform float scale;".endl()+"uniform float rotate;".endl()+"varying mat3 transform;".endl()+"void main()".endl()+"{".endl()+"   texCoord=attrTexCoord;".endl()+"   norm=attrVertNormal;".endl()+"   #ifdef TEX_TRANSFORM".endl()+"     vec3 coordinates=vec3(attrTexCoord.x, attrTexCoord.y,1.0);".endl()+"     float angle = radians( rotate );".endl()+"     vec2 scale= vec2(scale,scale);".endl()+"     vec2 translate= vec2(posX,posY);".endl()+"     transform = mat3(   scale.x * cos( angle ), scale.x * sin( angle ), 0.0,".endl()+"                           - scale.y * sin( angle ), scale.y * cos( angle ), 0.0,".endl()+"                          - 0.5 * scale.x * cos( angle ) + 0.5 * scale.y * sin( angle ) - 0.5 * translate.x*2.0 + 0.5,  - 0.5 * scale.x * sin( angle ) - 0.5 * scale.y * cos( angle ) - 0.5 * translate.y*2.0 + 0.5, 1.0);".endl()+"   #endif".endl()+"   gl_Position = projMatrix * mvMatrix * vec4(vPosition,  1.0);".endl()+"}",m="".endl()+"precision highp float;".endl()+"#ifdef HAS_TEXTURES".endl()+"  varying vec2 texCoord;".endl()+"  uniform sampler2D tex;".endl()+"  uniform sampler2D image;".endl()+"#endif".endl()+"varying mat3 transform;".endl()+"uniform float rotate;"+CGL.TextureEffect.getBlendCode().endl()+"#ifdef HAS_TEXTUREALPHA".endl()+"   uniform sampler2D imageAlpha;".endl()+"#endif".endl()+"uniform float amount;".endl()+"".endl()+"void main()".endl()+"{".endl()+"   vec4 blendRGBA=vec4(0.0,0.0,0.0,1.0);".endl()+"   #ifdef HAS_TEXTURES".endl()+"       vec2 tc=texCoord;".endl()+"       #ifdef TEX_FLIP_X".endl()+"           tc.x=1.0-tc.x;".endl()+"       #endif".endl()+"       #ifdef TEX_FLIP_Y".endl()+"           tc.y=1.0-tc.y;".endl()+"       #endif".endl()+"       #ifdef TEX_TRANSFORM".endl()+"           vec3 coordinates=vec3(tc.x, tc.y,1.0);".endl()+"           tc=(transform * coordinates ).xy;".endl()+"       #endif".endl()+"       blendRGBA=texture2D(image,tc);".endl()+"       vec3 blend=blendRGBA.rgb;".endl()+"       vec4 baseRGBA=texture2D(tex,texCoord);".endl()+"       vec3 base=baseRGBA.rgb;".endl()+"       vec3 colNew=blend;".endl()+"       colNew=_blend(base,blend);".endl()+"#ifdef REMOVE_ALPHA_SRC".endl()+"   blendRGBA.a=1.0;".endl()+"#endif".endl()+"#ifdef HAS_TEXTUREALPHA".endl()+"   vec4 colImgAlpha=texture2D(imageAlpha,texCoord);".endl()+"   float colImgAlphaAlpha=colImgAlpha.a;".endl()+"   #ifdef INVERT_ALPHA".endl()+"       colImgAlphaAlpha=1.0-colImgAlphaAlpha;".endl()+"   #endif".endl()+"   #ifdef ALPHA_FROM_LUMINANCE".endl()+"       vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), colImgAlpha.rgb ));".endl()+"       colImgAlphaAlpha=(gray.r+gray.g+gray.b)/3.0;".endl()+"   #endif".endl()+"   blendRGBA.a=colImgAlphaAlpha*blendRGBA.a;".endl()+"#endif".endl()+"blendRGBA.rgb=mix( colNew, base ,1.0-blendRGBA.a*amount);".endl()+"#endif".endl()+"   gl_FragColor = blendRGBA;".endl()+"}";T.setSource(h,m);new CGL.Uniform(T,"t","tex",0),new CGL.Uniform(T,"t","image",1),new CGL.Uniform(T,"t","imageAlpha",2);g.onValueChanged=function(){g.get()?T.define("INVERT_ALPHA"):T.removeDefine("INVERT_ALPHA"),T.compile()},u.onValueChanged=function(){u.get()?T.define("REMOVE_ALPHA_SRC"):T.removeDefine("REMOVE_ALPHA_SRC"),T.compile()},u.set(!0),f.onValueChanged=function(){"luminance"==f.get()?T.define("ALPHA_FROM_LUMINANCE"):T.removeDefine("ALPHA_FROM_LUMINANCE"),T.compile()},f.set("alpha channel");var p=o.addInPort(new Port(o,"flip x",OP_PORT_TYPE_VALUE,{display:"bool"})),v=o.addInPort(new Port(o,"flip y",OP_PORT_TYPE_VALUE,{display:"bool"}));p.onValueChanged=function(){p.get()?T.define("TEX_FLIP_X"):T.removeDefine("TEX_FLIP_X")},v.onValueChanged=function(){v.get()?T.define("TEX_FLIP_Y"):T.removeDefine("TEX_FLIP_Y")};var E=o.addInPort(new Port(o,"scale",OP_PORT_TYPE_VALUE,{display:"range"})),_=o.addInPort(new Port(o,"pos x",OP_PORT_TYPE_VALUE,{})),O=o.addInPort(new Port(o,"pos y",OP_PORT_TYPE_VALUE,{})),x=o.addInPort(new Port(o,"rotate",OP_PORT_TYPE_VALUE,{}));E.set(1);var C=new CGL.Uniform(T,"f","scale",E.get()),R=new CGL.Uniform(T,"f","posX",_.get()),w=new CGL.Uniform(T,"f","posY",O.get()),L=new CGL.Uniform(T,"f","rotate",x.get());E.onChange=e,_.onChange=e,O.onChange=e,x.onChange=e,l.onValueChanged=function(){CGL.TextureEffect.onChangeBlendSelect(T,l.get())};var U=new CGL.Uniform(T,"f","amount",a.get());a.onValueChanged=function(){U.setValue(a.get())},d.onValueChanged=function(){d.get()&&d.get().tex?T.define("HAS_TEXTUREALPHA"):T.removeDefine("HAS_TEXTUREALPHA"),T.compile()},s.onPreviewChanged=function(){s.showPreview?i.onTriggered=n:i.onTriggered=t},d.onPreviewChanged=function(){d.showPreview?i.onTriggered=r:i.onTriggered=t},i.onTriggered=t},Ops.Gl.TextureEffects.DrawImage.prototype=new CABLES.Op,Ops.Gl.Meshes.FullscreenRectangle=function(){function e(){var e=a.getViewPort().slice(),t=0,n=0;d=e[2],h=e[3],l.vertices=[t+d,n+h,0,t,n+h,0,t+d,n,0,t,n,0],i.get()?l.texCoords=[1,0,0,0,1,1,0,1]:l.texCoords=[1,1,0,1,1,0,0,0],l.verticesIndices=[0,1,2,3,1,2],s?s.setGeom(l):s=new CGL.Mesh(a,l)}Op.apply(this,arguments);var t=this;t.name="fullscreen rectangle";var n=t.addInPort(new Port(t,"render",OP_PORT_TYPE_FUNCTION)),r=t.addInPort(new Port(t,"Center in Canvas",OP_PORT_TYPE_VALUE,{display:"bool"})),o=t.addOutPort(new Port(t,"trigger",OP_PORT_TYPE_FUNCTION)),i=t.inValueBool("Flip Y"),a=t.patch.cgl,s=null,l=new CGL.Geometry("fullscreen rectangle"),d=0;t.onResize=e,r.onValueChanged=e,i.onValueChanged=e,n.onTriggered=function(){if((a.getViewPort()[2]!=d||a.getViewPort()[3]!=h)&&e(),a.pushPMatrix(),mat4.identity(a.pMatrix),mat4.ortho(a.pMatrix,0,d,h,0,-10,1e3),a.pushMvMatrix(),mat4.identity(a.mvMatrix),a.pushViewMatrix(),mat4.identity(a.vMatrix),r.get()){var t=0,n=0;d<a.canvasWidth&&(t=(a.canvasWidth-d)/2),h<a.canvasHeight&&(n=(a.canvasHeight-h)/2),a.setViewPort(t,n,d,h)}s.render(a.getShader()),a.gl.clear(a.gl.DEPTH_BUFFER_BIT),a.popPMatrix(),a.popMvMatrix(),a.popViewMatrix(),o.trigger()}},Ops.Gl.Meshes.FullscreenRectangle.prototype=new CABLES.Op,Ops.Gl.TextureEffects.Color=function(){Op.apply(this,arguments);var e=this;e.name="Color";var t=e.addInPort(new Port(e,"render",OP_PORT_TYPE_FUNCTION)),n=e.addInPort(new Port(e,"r",OP_PORT_TYPE_VALUE,{display:"range",colorPick:"true"})),r=e.addInPort(new Port(e,"g",OP_PORT_TYPE_VALUE,{display:"range"})),o=e.addInPort(new Port(e,"b",OP_PORT_TYPE_VALUE,{display:"range"})),i=e.addInPort(new Port(e,"a",OP_PORT_TYPE_VALUE,{display:"range"})),a=e.addOutPort(new Port(e,"trigger",OP_PORT_TYPE_FUNCTION)),s=e.patch.cgl,l=new CGL.Shader(s,"textureeffect color");e.onLoaded=l.compile;var d="".endl()+"precision highp float;".endl()+"#ifdef HAS_TEXTURES".endl()+"  varying vec2 texCoord;".endl()+"  uniform sampler2D tex;".endl()+"#endif".endl()+"uniform float r;".endl()+"uniform float g;".endl()+"uniform float b;".endl()+"uniform float a;".endl()+"".endl()+"void main()".endl()+"{".endl()+"   vec4 col=vec4(r,g,b,a);".endl()+"   gl_FragColor = col;".endl()+"}";l.setSource(l.getDefaultVertexShader(),d);new CGL.Uniform(l,"t","tex",0);n.set(1),r.set(1),o.set(1),i.set(1);new CGL.Uniform(l,"f","r",n),new CGL.Uniform(l,"f","g",r),new CGL.Uniform(l,"f","b",o),new CGL.Uniform(l,"f","a",i);t.onTriggered=function(){s.currentTextureEffect&&(s.setShader(l),s.currentTextureEffect.bind(),s.gl.activeTexture(s.gl.TEXTURE0),s.gl.bindTexture(s.gl.TEXTURE_2D,s.currentTextureEffect.getCurrentSourceTexture().tex),s.currentTextureEffect.finish(),s.setPreviousShader(),a.trigger())}},Ops.Gl.TextureEffects.Color.prototype=new CABLES.Op,Ops.Gl.TextureEffects.ImageCompose=function(){function e(){h&&h["delete"](),m&&m["delete"](),h=new CGL.TextureEffect(T,{isFloatingPointTexture:g.get()}),m=new CGL.Texture(T,{isFloatingPointTexture:g.get(),filter:C,wrap:R,width:s.get(),height:l.get()}),h.setSourceTexture(m),P.set(null),_=!1}function t(){h||e(),a.get()?(p=T.getViewPort()[2],v=T.getViewPort()[3]):(p=s.get(),v=l.get()),p==m.width&&v==m.height||0===p||0===v||(l.set(v),s.set(p),m.filter=CGL.Texture.FILTER_LINEAR,m.setSize(p,v),h.setSourceTexture(m)),P.get()&&(P.get().isPowerOfTwo()?o.uiAttr({warning:""}):o.uiAttr({warning:"texture dimensions not power of two! - texture filtering will not work."}))}function n(){"repeat"==f.get()&&(R=CGL.Texture.WRAP_REPEAT),"mirrored repeat"==f.get()&&(R=CGL.Texture.WRAP_MIRRORED_REPEAT),"clamp to edge"==f.get()&&(R=CGL.Texture.WRAP_CLAMP_TO_EDGE),_=!0,t()}function r(){"nearest"==d.get()&&(C=CGL.Texture.FILTER_NEAREST),"linear"==d.get()&&(C=CGL.Texture.FILTER_LINEAR),_=!0,t()}Op.apply(this,arguments);var o=this;o.name="image compose";var i=o.addInPort(new Port(o,"render",OP_PORT_TYPE_FUNCTION)),a=o.addInPort(new Port(o,"use viewport size",OP_PORT_TYPE_VALUE,{display:"bool"})),s=o.addInPort(new Port(o,"width",OP_PORT_TYPE_VALUE)),l=o.addInPort(new Port(o,"height",OP_PORT_TYPE_VALUE)),d=o.inValueSelect("filter",["nearest","linear","mipmap"]),f=o.inValueSelect("wrap",["clamp to edge","repeat","mirrored repeat"]),u=o.inValueSlider("Background Alpha",1),g=o.inValueBool("HDR"),c=o.addOutPort(new Port(o,"trigger",OP_PORT_TYPE_FUNCTION)),P=o.outTexture("texture_out");P.set(null);var T=o.patch.cgl,h=null,m=null,p=8,v=8,E=[0,0,0,0],_=!0,O="".endl()+"precision highp float;".endl()+"uniform float a;".endl()+"void main()".endl()+"{".endl()+"   gl_FragColor = vec4(0.0,0.0,0.0,a);".endl()+"}",x=new CGL.Shader(T,"imgcompose bg");x.setSource(x.getDefaultVertexShader(),O);var C=(new CGL.Uniform(x,"f","a",u),CGL.Texture.FILTER_LINEAR),R=CGL.Texture.WRAP_CLAMP_TO_EDGE;g.onChange=function(){_=!0},a.onValueChanged=function(){a.get()?(s.onValueChanged=null,l.onValueChanged=null):(s.onValueChanged=t,l.onValueChanged=t),t()};var w=function(){(!h||_)&&e();var n=T.getViewPort();E[0]=n[0],E[1]=n[1],E[2]=n[2],E[3]=n[3],t(),T.currentTextureEffect=h,h.setSourceTexture(m),h.startEffect(),T.setShader(x),T.currentTextureEffect.bind(),T.gl.activeTexture(T.gl.TEXTURE0),T.gl.bindTexture(T.gl.TEXTURE_2D,T.currentTextureEffect.getCurrentSourceTexture().tex),T.currentTextureEffect.finish(),T.setPreviousShader(),c.trigger(),P.set(h.getCurrentSourceTexture()),h.endEffect(),T.setViewPort(E[0],E[1],E[2],E[3])};f.set("clamp to edge"),f.onValueChanged=n,d.set("linear"),d.onValueChanged=r,a.set(!0),i.onTriggered=w,s.set(640),l.set(360)},Ops.Gl.TextureEffects.ImageCompose.prototype=new CABLES.Op,Ops.Ui.Comment=function(){Op.apply(this,arguments);var e=this;e.name="Comment";var t=e.addInPort(new Port(e,"title",OP_PORT_TYPE_VALUE,{type:"string"})),n=e.addInPort(new Port(e,"text",OP_PORT_TYPE_VALUE,{type:"string"}));t.set("comment"),n.set(""),t.onValueChange(function(){e.name=t.get(),e.uiAttr("title",e.name)})},Ops.Ui.Comment.prototype=new CABLES.Op,Ops.Deprecated.Gl.TextureEffects.Blur=function(){Op.apply(this,arguments);CABLES.Op.apply(this,arguments);var e=this,t=this.patch.cgl;this.name="Blur",this.render=this.addInPort(new Port(this,"render",OP_PORT_TYPE_FUNCTION)),this.trigger=this.addOutPort(new Port(this,"trigger",OP_PORT_TYPE_FUNCTION)),this.iterations=this.addInPort(new Port(this,"iterations",OP_PORT_TYPE_VALUE)),this.iterations.val=10;var n=new CGL.Shader(t);this.onLoaded=n.compile;var r="".endl()+"precision highp float;".endl()+"#ifdef HAS_TEXTURES".endl()+"  varying vec2 texCoord;".endl()+"  uniform sampler2D tex;".endl()+"  uniform float dirX;".endl()+"  uniform float dirY;".endl()+"  uniform float width;".endl()+"  uniform float height;".endl()+"#endif".endl()+"".endl()+"vec4 blur9(sampler2D texture, vec2 uv, vec2 red, vec2 dir)".endl()+"{".endl()+"   vec4 color = vec4(0.0);".endl()+"   vec2 offset1 = vec2(1.3846153846) * dir;".endl()+"   vec2 offset2 = vec2(3.2307692308) * dir;".endl()+"   color += texture2D(texture, uv) * 0.2270270270;".endl()+"   color += texture2D(texture, uv + (offset1 / red)) * 0.3162162162;".endl()+"   color += texture2D(texture, uv - (offset1 / red)) * 0.3162162162;".endl()+"   color += texture2D(texture, uv + (offset2 / red)) * 0.0702702703;".endl()+"   color += texture2D(texture, uv - (offset2 / red)) * 0.0702702703;".endl()+"   return color;".endl()+"}".endl()+"".endl()+"void main()".endl()+"{".endl()+"   vec4 col=vec4(1.0,0.0,0.0,1.0);".endl()+"   #ifdef HAS_TEXTURES".endl()+"       col=blur9(tex,texCoord,vec2(width,height),vec2(dirX,dirY));".endl()+"   #endif".endl()+"   gl_FragColor = col;".endl()+"}";n.setSource(n.getDefaultVertexShader(),r);var o=(new CGL.Uniform(n,"t","tex",0),new CGL.Uniform(n,"f","dirX",0)),i=new CGL.Uniform(n,"f","dirY",0),a=new CGL.Uniform(n,"f","width",0),s=new CGL.Uniform(n,"f","height",0),l=this.addInPort(new Port(this,"direction",OP_PORT_TYPE_VALUE,{display:"dropdown",values:["both","vertical","horizontal"]})),d=0;l.set("both"),l.onValueChange(function(){"both"==l.get()&&(d=0),"horizontal"==l.get()&&(d=1),"vertical"==l.get()&&(d=2)}),this.render.onTriggered=function(){if(t.currentTextureEffect){t.setShader(n),a.setValue(t.currentTextureEffect.getCurrentSourceTexture().width),s.setValue(t.currentTextureEffect.getCurrentSourceTexture().height);for(var r=0;r<e.iterations.val;r++)(0===d||2==d)&&(t.currentTextureEffect.bind(),t.gl.activeTexture(t.gl.TEXTURE0),t.gl.bindTexture(t.gl.TEXTURE_2D,t.currentTextureEffect.getCurrentSourceTexture().tex),o.setValue(0),i.setValue(1),t.currentTextureEffect.finish()),(0===d||1==d)&&(t.currentTextureEffect.bind(),t.gl.activeTexture(t.gl.TEXTURE0),t.gl.bindTexture(t.gl.TEXTURE_2D,t.currentTextureEffect.getCurrentSourceTexture().tex),o.setValue(1),i.setValue(0),t.currentTextureEffect.finish());t.setPreviousShader(),e.trigger.trigger()}}},Ops.Deprecated.Gl.TextureEffects.Blur.prototype=new CABLES.Op,Ops.Gl.Phong.PhongMaterial=function(){Op.apply(this,arguments);var e={};e.shader_frag="precision mediump float;\n{{MODULES_HEAD}}\nvarying mediump vec3 norm;\nvarying mediump vec3 vert;\nuniform mat4 normalMatrix;\nvarying mat4 mvMatrix;\nuniform mat4 modelMatrix;\n\n#ifdef INSTANCING\nvarying mat4 instModelMat;\n#endif\n\n// varying vec3 vTangent;\n// varying vec3 vBiTangent;\n\n\nuniform float r;\nuniform float g;\nuniform float b;\nuniform float a;\nuniform float mul;\nuniform float shininess;\nuniform float normalTexIntensity;\n\nuniform float shadowPass;\nuniform vec3 camPos;\n\nuniform float diffuseRepeatX;\nuniform float diffuseRepeatY;\n\n#ifdef HAS_TEXTURES\n    varying mediump vec2 texCoord;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        uniform sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_AO\n        uniform sampler2D texAo;\n    #endif\n    #ifdef HAS_TEXTURE_SPEC\n        uniform sampler2D texSpec;\n    #endif\n    #ifdef HAS_TEXTURE_NORMAL\n        uniform sampler2D texNormal;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        uniform sampler2D texOpacity;\n    #endif\n#endif\n\n//uniform sampler2D depthTex;\n\nuniform struct Light\n{\n    float type;\n    float attenuation;\n    vec3 pos;\n    vec3 target;\n    vec3 color;\n    float intensity;\n    float cone;\n    mat4 depthMVP;\n    float mul;\n} light;\n\nuniform Light lights[4];\n\nvoid main()\n{\n    vec4 surfaceColor = vec4(r,g,b,a);\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n            #ifdef TEXTURED_POINTS\n                surfaceColor=texture2D(tex,vec2(gl_PointCoord.x*diffuseRepeatX,(1.0-gl_PointCoord.y)*diffuseRepeatY));\n            #endif\n            #ifndef TEXTURED_POINTS\n                surfaceColor=texture2D(tex,vec2(texCoord.x*diffuseRepeatX,(texCoord.y)*diffuseRepeatY));\n            #endif\n            surfaceColor.a*=a;\n            #ifdef COLORIZE_TEXTURE\n                surfaceColor.r*=r;\n                surfaceColor.g*=g;\n                surfaceColor.b*=b;\n            #endif\n        #endif\n    #endif\n\n    vec3 theColor=vec3(0.0,0.0,0.0);\n\n\n    if(shadowPass==0.0)\n    for(int l=0;l<NUM_LIGHTS;l++)\n    {\n        float lightIntensity=lights[l].mul*2.5;\n        if(lightIntensity>0.0)\n        {\n            vec3 lightColor = lights[l].color;\n\n            #ifndef HAS_TEXTURE_NORMAL\n                vec3 normal = normalize(mat3(normalMatrix) * norm);\n            #endif\n\n            #ifdef HAS_TEXTURE_NORMAL\n                // #define CALC_TANGENT\n                vec3 tnorm= texture2D( texNormal,vec2(texCoord.x*diffuseRepeatX,(texCoord.y)*diffuseRepeatY)  ).xyz*2.0-1.0;\n                vec3 tangent,binormal;\n\n\n                // #ifndef CALC_TANGENT\n                // tangent=vTangent;\n                // binormal=vBiTangent;\n                // #endif\n                // float normalScale=normalTexIntensity24.5;\n                // #ifdef CALC_TANGENT\n                    vec3 c1 = cross(norm, vec3(0.0, 0.0, 1.0));\n                    tangent = c1;\n                    tangent = normalize(tangent);\n                    binormal = cross(norm, tangent);\n                    binormal = normalize(binormal);\n                    // tangent = c1;\n                    // tangent = normalize(vec3(modelMatrix*vec4(tangent,1.0)));\n                    // binormal = cross(norm, tangent);\n                    // binormal = normalize(vec3(modelMatrix*vec4(binormal,1.0)));\n                // #endif\n\n                tnorm = (tangent*tnorm.x + binormal*tnorm.y + norm*tnorm.z);\n                vec3 normal = normalize( mat3(normalMatrix) * (norm+tnorm*(normalTexIntensity*30.0)) );\n\n            #endif\n\n            {{MODULE_NORMAL}}\n\n            #ifdef INSTANCING\n            vec3 fragPosition = vec3(instModelMat * vec4(vert, 1.0)); //calculate the location of this fragment (pixel) in world coordinates\n            #endif\n            #ifndef INSTANCING\n            vec3 fragPosition = vec3(modelMatrix * vec4(vert, 1.0)); //calculate the location of this fragment (pixel) in world coordinates\n            #endif\n\n            vec3 surfaceToLight = normalize(lights[l].pos-fragPosition);\n            vec3 surfaceToCamera = normalize(camPos-fragPosition);\n            // vec3 normal = normalize(transpose(inverse(mat3(model))) * fragNormal);\n            vec3 ambient=vec3(0.0,0.0,0.0);\n\n            //calculate the cosine of the angle of incidence\n            float diffuseCoefficient = max(0.0, dot(surfaceToLight,normal));\n            vec3 diffuse = diffuseCoefficient * surfaceColor.rgb * lightColor * lightIntensity;\n\n            // specular.....\n            vec3 specular=vec3(0.0,0.0,0.0);\n            #ifdef DO_RENDER_SPECULAR\n                vec3 materialSpecularColor = vec3(1.0,1.0,1.0);\n\n                float specularCoefficient = 0.0;\n                if(diffuseCoefficient > 0.0)\n                    specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), shininess);\n                specular =(specularCoefficient * materialSpecularColor * lightIntensity*0.2);\n\n                #ifdef HAS_TEXTURE_SPEC\n                    specular*=1.0-texture2D( texSpec, texCoord ).rgb;\n                #endif\n            #endif\n\n            // attenuation\n            float distanceToLight = length(lights[l].pos-fragPosition);\n            float attenuation = 1.0 / (1.0 + lights[l].attenuation * (distanceToLight * distanceToLight));\n\n\n\n            // SPOT LIGHT\n            if(lights[l].type!=0.0)\n            {\n                attenuation=1.0;\n                vec3 coneDirection = normalize( (lights[l].target-lights[l].pos) );\n                float spotEffect = dot(normalize(coneDirection), normalize(-surfaceToLight));\n                float lightToSurfaceAngle = degrees(acos(dot(surfaceToLight, coneDirection)));\n\n                // shadows...\n                vec4 shadowCoord = lights[l].depthMVP * vec4(vert,1.0);\n                //float s=texture2D( depthTex, shadowCoord.xy  ).z;\n                float s=1.0;\n\n                float f=100.0;\n                float n=0.1;\n                float c=(2.0*n)/(f+n-s*(f-n));\n                attenuation=c;\n\n                if( spotEffect < lights[l].cone) attenuation=0.0;\n            }\n\n            theColor += ambient + attenuation*(diffuse+(specular) );\n        }\n    }\n\n    #ifdef DO_GAMME_CORRECT\n        vec3 linearColor = theColor;\n        vec3 gamma = vec3(1.0/2.2);\n        theColor = pow(linearColor, gamma);\n    #endif\n\n    vec4 col=vec4(theColor, surfaceColor.a);\n\n    #ifdef HAS_TEXTURE_AO\n       col.rgb*=texture2D( texAo, texCoord ).rgb;\n    #endif\n\n    {{MODULE_COLOR}}\n// col.rgb=normalize(vBiTangent);\n    gl_FragColor = col;\n}\n",e.shader_vert="precision mediump float;\n{{MODULES_HEAD}}\n\nattribute vec3 vPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nattribute vec3 attrVertNormal;\nattribute vec2 attrTexCoord;\n\n// attribute vec3 attrTangent;\n// attribute vec3 attrBiTangent;\nvarying vec3 vTangent;\nvarying vec3 vBiTangent;\n\n\nvarying mediump vec3 norm;\nvarying mediump vec3 vert;\nvarying mat4 mvMatrix;\nuniform mat4 normalMatrix;\n\n#ifdef HAS_TEXTURES\n    varying mediump vec2 texCoord;\n#endif\n\nvoid main()\n{\n    norm=attrVertNormal;\n    vert=vPosition;\n\n    // vTangent=attrTangent;\n    // vBiTangent=attrBiTangent;\n\n    #ifdef HAS_TEXTURES\n        texCoord=attrTexCoord;\n    #endif\n\n    vec4 pos = vec4( vPosition, 1. );\n    mvMatrix=viewMatrix * modelMatrix;\n    {{MODULE_VERTEX_POSITION}}\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n",this.name="PhongMaterial";var t=this.patch.cgl,n=this.addInPort(new Port(this,"render",OP_PORT_TYPE_FUNCTION)),r=this.addInPort(new Port(this,"gamma correction",OP_PORT_TYPE_VALUE,{display:"bool"})),o=this.addOutPort(new Port(this,"trigger",OP_PORT_TYPE_FUNCTION)),a=this.addOutPort(new Port(this,"shader",OP_PORT_TYPE_OBJECT));a.ignoreValueSerialize=!0;var s=16;r.set(!1);var l=function(){r.get()?d.define("DO_GAMME_CORRECT"):d.removeDefine("DO_GAMME_CORRECT")};r.onValueChanged=l;var d=new CGL.Shader(t,"PhongMaterial");d.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_NORMAL","MODULE_BEGIN_FRAG"]);var f=e.shader_frag;d.setSource(e.shader_vert,f),a.set(d);var u=[];depthTex=new CGL.Uniform(d,"t","depthTex",5);var g=new CGL.Uniform(d,"f","shadowPass",0);for(i=0;i<s;i++){var c=i;u[c]={},u[c].pos=new CGL.Uniform(d,"3f","lights["+c+"].pos",[0,11,0]),u[c].target=new CGL.Uniform(d,"3f","lights["+c+"].target",[0,0,0]),u[c].color=new CGL.Uniform(d,"3f","lights["+c+"].color",[1,1,1]),u[c].attenuation=new CGL.Uniform(d,"f","lights["+c+"].attenuation",.1),u[c].type=new CGL.Uniform(d,"f","lights["+c+"].type",0),u[c].cone=new CGL.Uniform(d,"f","lights["+c+"].cone",.8),u[c].mul=new CGL.Uniform(d,"f","lights["+c+"].mul",1)}var P=this.addInPort(new Port(this,"Shiny",OP_PORT_TYPE_VALUE,{display:"bool"}));P.onValueChanged=function(){P.get()?d.define("DO_RENDER_SPECULAR"):d.removeDefine("DO_RENDER_SPECULAR")};var T=this.addInPort(new Port(this,"Shininess",OP_PORT_TYPE_VALUE,{display:"range"}));T.onValueChanged=function(){var e=200-199*T.get();T.uniform?T.uniform.setValue(e):T.uniform=new CGL.Uniform(d,"f","shininess",e)},T.set(.001);var h=this.addInPort(new Port(this,"Normal Texture Intensity",OP_PORT_TYPE_VALUE,{
display:"range"}));h.onValueChanged=function(){h.uniform?h.uniform.setValue(h.get()):h.uniform=new CGL.Uniform(d,"f","normalTexIntensity",h.get())},h.set(1);var m=this.addInPort(new Port(this,"diffuse r",OP_PORT_TYPE_VALUE,{display:"range",colorPick:"true"}));m.onValueChanged=function(){m.uniform?m.uniform.setValue(m.get()):m.uniform=new CGL.Uniform(d,"f","r",m.get())};var p=this.addInPort(new Port(this,"diffuse g",OP_PORT_TYPE_VALUE,{display:"range"}));p.onValueChanged=function(){p.uniform?p.uniform.setValue(p.get()):p.uniform=new CGL.Uniform(d,"f","g",p.get())};var v=this.addInPort(new Port(this,"diffuse b",OP_PORT_TYPE_VALUE,{display:"range"}));v.onValueChanged=function(){v.uniform?v.uniform.setValue(v.get()):v.uniform=new CGL.Uniform(d,"f","b",v.get())};var E=this.addInPort(new Port(this,"diffuse a",OP_PORT_TYPE_VALUE,{display:"range"}));E.onValueChanged=function(){E.uniform?E.uniform.setValue(E.get()):E.uniform=new CGL.Uniform(d,"f","a",E.get())},m.set(Math.random()),p.set(Math.random()),v.set(Math.random()),E.set(1);var _=this.addInPort(new Port(this,"colorize texture",OP_PORT_TYPE_VALUE,{display:"bool"}));_.onValueChanged=function(){_.get()?d.define("COLORIZE_TEXTURE"):d.removeDefine("COLORIZE_TEXTURE")};var O=this.addInPort(new Port(this,"texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),x=null;d.bindTextures=Y,O.onValueChanged=function(){if(O.get()){if(null!==x)return;d.removeUniform("tex"),d.define("HAS_TEXTURE_DIFFUSE"),x=new CGL.Uniform(d,"t","tex",0)}else d.removeUniform("tex"),d.removeDefine("HAS_TEXTURE_DIFFUSE"),x=null};var C=this.addInPort(new Port(this,"AO Texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),R=null;C.ignoreValueSerialize=!0,d.bindTextures=Y,C.onValueChanged=function(){if(C.get()){if(null!==R)return;d.removeUniform("texAo"),d.define("HAS_TEXTURE_AO"),R=new CGL.Uniform(d,"t","texAo",1)}else d.removeUniform("texAo"),d.removeDefine("HAS_TEXTURE_AO"),R=null};var w=this.addInPort(new Port(this,"Specular Texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),L=null;w.onValueChanged=function(){if(w.get()){if(null!==L)return;d.removeUniform("texSpec"),d.define("HAS_TEXTURE_SPEC"),L=new CGL.Uniform(d,"t","texSpec",2)}else d.removeUniform("texSpec"),d.removeDefine("HAS_TEXTURE_SPEC"),L=null};var U=this.addInPort(new Port(this,"Normal Texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),A=null;U.onValueChanged=function(){if(U.get()){if(null!==A)return;d.removeUniform("texNormal"),d.define("HAS_TEXTURE_NORMAL"),A=new CGL.Uniform(d,"t","texNormal",3)}else d.removeUniform("texNormal"),d.removeDefine("HAS_TEXTURE_NORMAL"),A=null};var I=this.addInPort(new Port(this,"diffuseRepeatX",OP_PORT_TYPE_VALUE)),S=this.addInPort(new Port(this,"diffuseRepeatY",OP_PORT_TYPE_VALUE));I.set(1),S.set(1),I.onValueChanged=function(){M.setValue(I.get())},S.onValueChanged=function(){V.setValue(S.get())};var M=new CGL.Uniform(d,"f","diffuseRepeatX",I.get()),V=new CGL.Uniform(d,"f","diffuseRepeatY",S.get()),y=this.addInPort(new Port(this,"textured points",OP_PORT_TYPE_VALUE,{display:"bool"}));y.onValueChanged=function(){y.get()?d.define("TEXTURED_POINTS"):d.removeDefine("TEXTURED_POINTS")};var G=-1,D=function(){var e=0,n=0,r=0;if(t.frameStore.phong&&t.frameStore.phong.lights)for(n in t.frameStore.phong.lights)r++;else r=0;if(r!=G&&(G=r,d.define("NUM_LIGHTS",""+Math.max(G,1))),t.frameStore.phong&&t.frameStore.phong.lights){if(e=0,d)for(n in t.frameStore.phong.lights)u[e].pos.setValue(t.frameStore.phong.lights[n].pos),t.frameStore.phong.lights[n].changed=!1,t.frameStore.phong.lights[n].target&&u[e].target.setValue(t.frameStore.phong.lights[n].target),u[e].color.setValue(t.frameStore.phong.lights[n].color),u[e].attenuation.setValue(t.frameStore.phong.lights[n].attenuation),u[e].type.setValue(t.frameStore.phong.lights[n].type),t.frameStore.phong.lights[n].cone&&u[e].cone.setValue(t.frameStore.phong.lights[n].cone),t.frameStore.phong.lights[n].depthTex&&(u[e].texDepthTex=t.frameStore.phong.lights[n].depthTex),u[e].mul.setValue(t.frameStore.phong.lights[n].mul),e++}else;},Y=function(){if(O.get()&&(t.gl.activeTexture(t.gl.TEXTURE0),t.gl.bindTexture(t.gl.TEXTURE_2D,O.get().tex)),C.get()&&(t.gl.activeTexture(t.gl.TEXTURE1),t.gl.bindTexture(t.gl.TEXTURE_2D,C.get().tex)),w.get()&&(t.gl.activeTexture(t.gl.TEXTURE2),t.gl.bindTexture(t.gl.TEXTURE_2D,w.get().tex)),U.get()&&(t.gl.activeTexture(t.gl.TEXTURE3),t.gl.bindTexture(t.gl.TEXTURE_2D,U.get().tex)),g.setValue(0),t.frameStore.phong&&t.frameStore.phong.lights)for(i in t.frameStore.phong.lights)1==t.frameStore.phong.lights[i].shadowPass&&g.setValue(1)},N=function(){d&&(t.setShader(d),D(),d.bindTextures(),o.trigger(),t.setPreviousShader())};d.bindTextures=Y,d.define("NUM_LIGHTS","1"),l(),this.onLoaded=d.compile,n.onTriggered=N,N()},Ops.Gl.Phong.PhongMaterial.prototype=new CABLES.Op,Ops.Math.Multiply=function(){function e(){var e=n.get(),t=r.get();isNaN(e)&&(e=0),isNaN(t)&&(t=0),o.set(e*t)}Op.apply(this,arguments);var t=this;t.name="multiply";var n=t.addInPort(new Port(t,"number1")),r=t.addInPort(new Port(t,"number2")),o=t.addOutPort(new Port(t,"result"));n.onValueChanged=e,r.onValueChanged=e,n.set(1),r.set(2)},Ops.Math.Multiply.prototype=new CABLES.Op,Ops.Gl.Render2Texture=function(){function e(){(!c||P)&&(c&&c["delete"](),c=new CGL.Framebuffer(r,8,8,{isFloatingPointTexture:g.get()}),f.set(c.getTextureColor()),u.set(c.getTextureDepth()),P=!1),i.val&&(a.set(r.getViewPort()[2]),s.set(r.getViewPort()[3])),(c.getWidth()!=a.get()||c.getHeight()!=s.get())&&c.setSize(a.get(),s.get()),c.renderStart(r),d.trigger(),c.renderEnd(r),r.resetViewPort()}function t(){e(),f.val.preview()}Op.apply(this,arguments);var n=this,r=n.patch.cgl;n.name="render to texture";var o=n.addInPort(new Port(n,"render",OP_PORT_TYPE_FUNCTION)),i=n.addInPort(new Port(n,"use viewport size",OP_PORT_TYPE_VALUE,{display:"bool"})),a=n.addInPort(new Port(n,"texture width")),s=n.addInPort(new Port(n,"texture height")),l=n.addInPort(new Port(n,"filter",OP_PORT_TYPE_VALUE,{display:"dropdown",values:["nearest","linear","mipmap"]})),d=n.addOutPort(new Port(n,"trigger",OP_PORT_TYPE_FUNCTION)),f=n.outTexture("texture"),u=n.outTexture("textureDepth"),g=n.inValueBool("HDR"),c=null;a.set(512),s.set(512),i.set(!0),l.set("linear");var P=!0;g.onChange=function(){P=!0};var T=function(){P=!0};f.onPreviewChanged=function(){f.showPreview?o.onTriggered=t:o.onTriggered=e},o.onTriggered=e,l.onValueChange(T)},Ops.Gl.Render2Texture.prototype=new CABLES.Op,Ops.Gl.RandomCluster=function(){function e(){for(var e=0;e<h.length;e++)T.pushMvMatrix(),mat4.translate(T.mvMatrix,T.mvMatrix,h[e]),mat4.rotateX(T.mvMatrix,T.mvMatrix,m[e][0]),mat4.rotateY(T.mvMatrix,T.mvMatrix,m[e][1]),mat4.rotateZ(T.mvMatrix,T.mvMatrix,m[e][2]),c.set(e),P.set(p[e]),g.trigger(),T.popMvMatrix()}function t(){return vec3.fromValues(l.get()*(Math.seededRandom()-.5)*a.get(),d.get()*(Math.seededRandom()-.5)*a.get(),f.get()*(Math.seededRandom()-.5)*a.get())}function n(){h.length=0,m.length=0,p.length=0,Math.randomSeed=s.get();for(var e=u.get(),n=0;n<i.get();n++){p.push(Math.seededRandom());var r=t();if(e)for(;vec3.len(r)>a.get()/2;)r=t();h.push(r),m.push(vec3.fromValues(360*Math.seededRandom()*CGL.DEG2RAD,360*Math.seededRandom()*CGL.DEG2RAD,360*Math.seededRandom()*CGL.DEG2RAD))}}Op.apply(this,arguments);var r=this;r.name="random cluster";var o=r.addInPort(new Port(r,"exe",OP_PORT_TYPE_FUNCTION)),i=r.addInPort(new Port(r,"num")),a=r.addInPort(new Port(r,"size")),s=r.addInPort(new Port(r,"random seed")),l=r.addInPort(new Port(r,"scaleX",OP_PORT_TYPE_VALUE,{display:"range"})),d=r.addInPort(new Port(r,"scaleY",OP_PORT_TYPE_VALUE,{display:"range"})),f=r.addInPort(new Port(r,"scaleZ",OP_PORT_TYPE_VALUE,{display:"range"})),u=r.inValueBool("round",!1),g=r.addOutPort(new Port(r,"trigger",OP_PORT_TYPE_FUNCTION)),c=r.addOutPort(new Port(r,"index")),P=r.addOutPort(new Port(r,"rnd")),T=r.patch.cgl,h=[],m=[],p=[];l.set(1),d.set(1),f.set(1);vec3.create(),mat4.create();o.onTriggered=e,a.set(20),s.set(1),s.onChange=n,i.onChange=n,a.onChange=n,l.onChange=n,f.onChange=n,d.onChange=n,u.onChange=n,i.set(100)},Ops.Gl.RandomCluster.prototype=new CABLES.Op,Ops.Deprecated.Gl.Matrix.Transform=function(){function e(){l=!1,(0!==n.posX.get()||0!==n.posY.get()||0!==n.posZ.get())&&(l=!0),vec3.set(o,n.posX.get(),n.posY.get(),n.posZ.get()),d=!1}function t(){s=!1,(0!==n.scaleX.get()||0!==n.scaleY.get()||0!==n.scaleZ.get())&&(s=!0),vec3.set(i,n.scaleX.get(),n.scaleY.get(),n.scaleZ.get()),f=!1}Op.apply(this,arguments);Op.apply(this,arguments);var n=this,r=n.patch.cgl;this.name="transform",this.render=this.addInPort(new Port(this,"render",OP_PORT_TYPE_FUNCTION)),this.trigger=this.addOutPort(new Port(this,"trigger",OP_PORT_TYPE_FUNCTION)),this.posX=this.addInPort(new Port(this,"posX")),this.posY=this.addInPort(new Port(this,"posY")),this.posZ=this.addInPort(new Port(this,"posZ")),this.scaleX=this.addInPort(new Port(this,"scaleX")),this.scaleY=this.addInPort(new Port(this,"scaleY")),this.scaleZ=this.addInPort(new Port(this,"scaleZ")),this.rotX=this.addInPort(new Port(this,"rotX")),this.rotY=this.addInPort(new Port(this,"rotY")),this.rotZ=this.addInPort(new Port(this,"rotZ"));var o=vec3.create(),i=vec3.create(),a=mat4.create();mat4.identity(a);var s=!1,l=!1,d=!0,f=!0,u=!0;this.render.onTriggered=function(){var o=!1;d&&(e(),o=!0),f&&(t(),o=!0),u&&(o=!0),o&&g(),r.pushMvMatrix(),mat4.multiply(r.mvMatrix,r.mvMatrix,a),n.trigger.trigger(),r.popMvMatrix()};var g=function(){mat4.identity(a),l&&mat4.translate(a,a,o),0!==n.rotX.get()&&mat4.rotateX(a,a,n.rotX.get()*CGL.DEG2RAD),0!==n.rotY.get()&&mat4.rotateY(a,a,n.rotY.get()*CGL.DEG2RAD),0!==n.rotZ.get()&&mat4.rotateZ(a,a,n.rotZ.get()*CGL.DEG2RAD),s&&mat4.scale(a,a,i),u=!1};this.translateChanged=function(){d=!0},this.scaleChanged=function(){f=!0},this.rotChanged=function(){u=!0},this.rotX.onValueChanged=this.rotChanged,this.rotY.onValueChanged=this.rotChanged,this.rotZ.onValueChanged=this.rotChanged,this.scaleX.onValueChanged=this.scaleChanged,this.scaleY.onValueChanged=this.scaleChanged,this.scaleZ.onValueChanged=this.scaleChanged,this.posX.onValueChanged=this.translateChanged,this.posY.onValueChanged=this.translateChanged,this.posZ.onValueChanged=this.translateChanged,this.rotX.set(0),this.rotY.set(0),this.rotZ.set(0),this.scaleX.set(1),this.scaleY.set(1),this.scaleZ.set(1),this.posX.set(0),this.posY.set(0),this.posZ.set(0),g()},Ops.Deprecated.Gl.Matrix.Transform.prototype=new CABLES.Op,Ops.Gl.Matrix.Transform=function(){function e(){m=!1,(0!==i.get()||0!==a.get()||0!==s.get())&&(m=!0),vec3.set(c,i.get(),a.get(),s.get()),p=!1}function t(){h=!1,0!==l.get()&&(h=!0),vec3.set(P,l.get(),l.get(),l.get()),v=!1}Op.apply(this,arguments);var n=this;n.name="Transform";var r=n.addInPort(new Port(n,"render",OP_PORT_TYPE_FUNCTION)),o=n.addOutPort(new Port(n,"trigger",OP_PORT_TYPE_FUNCTION)),i=n.addInPort(new Port(n,"posX")),a=n.addInPort(new Port(n,"posY")),s=n.addInPort(new Port(n,"posZ")),l=n.addInPort(new Port(n,"scale")),d=n.addInPort(new Port(n,"rotX")),f=n.addInPort(new Port(n,"rotY")),u=n.addInPort(new Port(n,"rotZ")),g=n.patch.cgl,c=vec3.create(),P=vec3.create(),T=mat4.create();mat4.identity(T);var h=!1,m=!1,p=!0,v=!0,E=!0;r.onTriggered=function(){var n=!1;p&&(e(),n=!0),v&&(t(),n=!0),E&&(n=!0),n&&_(),g.pushMvMatrix(),mat4.multiply(g.mvMatrix,g.mvMatrix,T),o.trigger(),g.popMvMatrix()};var _=function(){mat4.identity(T),m&&mat4.translate(T,T,c),0!==d.get()&&mat4.rotateX(T,T,d.get()*CGL.DEG2RAD),0!==f.get()&&mat4.rotateY(T,T,f.get()*CGL.DEG2RAD),0!==u.get()&&mat4.rotateZ(T,T,u.get()*CGL.DEG2RAD),h&&mat4.scale(T,T,P),E=!1},O=function(){p=!0},v=function(){v=!0},E=function(){E=!0};d.onChange=E,f.onChange=E,u.onChange=E,l.onChange=v,i.onChange=O,a.onChange=O,s.onChange=O,d.set(0),f.set(0),u.set(0),l.set(1),i.set(0),a.set(0),s.set(0),_()},Ops.Gl.Matrix.Transform.prototype=new CABLES.Op,Ops.Gl.Meshes.Cone=function(){function e(){var e=Math.round(s.get()),t=Math.round(a.get());2>e&&(e=2),2>t&&(t=2);var r=l.get();n(r,d.get(),e,t)}function t(e,t){var n,r=Math.abs(e),o=(t?1:2)*Math.PI/e,i=[],a=[];for(i[0]=0,a[0]=1,n=1;r>n;n++)i[n]=Math.sin(o*n),a[n]=Math.cos(o*n);return t?(i[r]=0,a[r]=-1):(i[r]=i[0],a[r]=a[0]),{cost:a,sint:i}}function n(e,n,r,o){var a=e,s=0,l=new CGL.Geometry,d=t(-o,!1),f=n/(r>0?r:1),P=e/(r>0?r:1),T=n/Math.sqrt(n*n+e*e),h=e/Math.sqrt(n*n+e*e);for(l.vertices[0]=0,l.vertices[1]=0,l.vertices[2]=s,l.vertexNormals[0]=0,l.vertexNormals[1]=0,l.vertexNormals[2]=-1,idx=3,j=0;j<o;j++,idx+=3)l.vertices[idx]=d.cost[j]*a,l.vertices[idx+1]=d.sint[j]*a,l.vertices[idx+2]=s,l.vertexNormals[idx]=0,l.vertexNormals[idx+1]=0,l.vertexNormals[idx+2]=-1;for(i=0;i<r+1;i++){for(j=0;j<o;j++,idx+=3)l.vertices[idx]=d.cost[j]*a,l.vertices[idx+1]=d.sint[j]*a,l.vertices[idx+2]=s,l.vertexNormals[idx]=d.cost[j]*T,l.vertexNormals[idx+1]=d.sint[j]*T,l.vertexNormals[idx+2]=h;s+=f,a-=P}for(j=0,idx=0;j<o;j++,idx+=2)l.verticesIndices[idx]=0,l.verticesIndices[idx+1]=j+1;for(l.verticesIndices[idx]=0,l.verticesIndices[idx+1]=1,idx+=2,i=0;i<r;i++,idx+=2){for(offset=1+(i+1)*o,j=0;j<o;j++,idx+=2)l.verticesIndices[idx]=offset+j,l.verticesIndices[idx+1]=offset+j+o;l.verticesIndices[idx]=offset,l.verticesIndices[idx+1]=offset+o}c=new CGL.Mesh(g,l,g.gl.TRIANGLE_STRIP),u.set(l)}Op.apply(this,arguments);var r=this;r.name="Cone";var o=r.addInPort(new Port(r,"render",OP_PORT_TYPE_FUNCTION)),a=r.addInPort(new Port(r,"slices",OP_PORT_TYPE_VALUE)),s=r.addInPort(new Port(r,"stacks",OP_PORT_TYPE_VALUE)),l=r.addInPort(new Port(r,"radius",OP_PORT_TYPE_VALUE)),d=r.addInPort(new Port(r,"height",OP_PORT_TYPE_VALUE)),f=r.addOutPort(new Port(r,"trigger",OP_PORT_TYPE_FUNCTION)),u=r.addOutPort(new Port(r,"geometry",OP_PORT_TYPE_OBJECT));a.set(32),s.set(5),l.set(1),d.set(2),u.ignoreValueSerialize=!0;var g=r.patch.cgl,c=null;o.onTriggered=function(){null!==c&&c.render(g.getShader()),f.trigger()},s.onValueChanged=e,a.onValueChanged=e,l.onValueChanged=e,d.onValueChanged=e,e()},Ops.Gl.Meshes.Cone.prototype=new CABLES.Op,Ops.Gl.ClearColor=function(){Op.apply(this,arguments);var e=this;e.name="ClearColor";var t=e.addInPort(new Port(e,"render",OP_PORT_TYPE_FUNCTION)),n=e.addOutPort(new Port(e,"trigger",OP_PORT_TYPE_FUNCTION)),r=e.addInPort(new Port(e,"r",OP_PORT_TYPE_VALUE,{display:"range",colorPick:"true"})),o=e.inValueSlider("g",.3),i=e.inValueSlider("b",.3),a=e.inValueSlider("a",1),s=e.patch.cgl;t.onTriggered=function(){s.gl.clearColor(r.get(),o.get(),i.get(),a.get()),s.gl.clear(s.gl.COLOR_BUFFER_BIT|s.gl.DEPTH_BUFFER_BIT),n.trigger()}},Ops.Gl.ClearColor.prototype=new CABLES.Op,Ops.Sequence=function(){Op.apply(this,arguments);var e=this;e.name="sequence";var t=e.addInPort(new Port(e,"exe",OP_PORT_TYPE_FUNCTION)),n=[],r=[],o=function(){for(var e=0;e<r.length;e++)r[e].trigger()};t.onTriggered=o;for(var i=16,a=0;i>a;a++)if(r.push(e.addOutPort(new Port(e,"trigger "+a,OP_PORT_TYPE_FUNCTION))),i-1>a){var s=e.addInPort(new Port(e,"exe "+a,OP_PORT_TYPE_FUNCTION));s.onTriggered=o,n.push(s)}},Ops.Sequence.prototype=new CABLES.Op,Ops.Devices.Mouse.Mouse=function(){function e(e,t){if(s.normalize.get()){var n=l.canvas.width,r=l.canvas.height;P==document.body&&(n=P.clientWidth,r=P.clientHeight),s.mouseX.set((e/n*2-1)*s.multiply.get()),s.mouseY.set((t/r*2-1)*s.multiply.get())}else s.mouseX.set(e*s.multiply.get()),s.mouseY.set(t*s.multiply.get())}function t(){0>=c&&(c=.01);var t=Math.abs(m-T),n=Math.round(t/c,0);T=m>T?T+n:T-n;var r=Math.abs(p-h),o=Math.round(r/c,0);h=p>h?h+o:h-o,e(T,h)}function n(e){s.mouseClick.trigger()}function r(e){v=0,E=0,c=100,"Canvas"==f.get()&&s.smooth.get()&&(m=l.canvas.width/2,p=l.canvas.height/2),s.mouseOver.set(!1),s.mouseDown.set(!1)}function o(){P.removeEventListener("click",n),P.removeEventListener("mousemove",L),P.removeEventListener("mouseleave",r),P.removeEventListener("mousedown",C),P.removeEventListener("mouseup",R),P.removeEventListener("mouseenter",x),P.removeEventListener("contextmenu",w),P=null}function i(){P&&o(),P=l.canvas,"Document"==f.get()&&(P=document.body),P.addEventListener("click",n),P.addEventListener("mousemove",L),P.addEventListener("mouseleave",r),P.addEventListener("mousedown",C),P.addEventListener("mouseup",R),P.addEventListener("mouseenter",x),P.addEventListener("contextmenu",w)}Op.apply(this,arguments);var a=this,s=this,l=s.patch.cgl;this.name="mouse",this.mouseX=this.addOutPort(new Port(this,"x",OP_PORT_TYPE_VALUE)),this.mouseY=this.addOutPort(new Port(this,"y",OP_PORT_TYPE_VALUE)),this.mouseDown=this.addOutPort(new Port(this,"button down",OP_PORT_TYPE_VALUE)),this.mouseClick=this.addOutPort(new Port(this,"click",OP_PORT_TYPE_FUNCTION));var d=this.addOutPort(new Port(this,"Button Up",OP_PORT_TYPE_FUNCTION));this.mouseClickRight=this.addOutPort(new Port(this,"click right",OP_PORT_TYPE_FUNCTION)),this.mouseOver=this.addOutPort(new Port(this,"mouseOver",OP_PORT_TYPE_VALUE)),this.relative=this.addInPort(new Port(this,"relative",OP_PORT_TYPE_VALUE,{display:"bool"})),this.normalize=this.addInPort(new Port(this,"normalize",OP_PORT_TYPE_VALUE,{display:"bool"})),this.smooth=this.addInPort(new Port(this,"smooth",OP_PORT_TYPE_VALUE,{display:"bool"})),this.smoothSpeed=this.addInPort(new Port(this,"smoothSpeed",OP_PORT_TYPE_VALUE));var f=a.addInPort(new Port(a,"Area",OP_PORT_TYPE_VALUE,{display:"dropdown",values:["Canvas","Document"]}));f.set("Canvas");var u=this.addOutPort(new Port(this,"button",OP_PORT_TYPE_VALUE));this.multiply=this.addInPort(new Port(this,"multiply",OP_PORT_TYPE_VALUE)),this.flipY=this.addInPort(new Port(this,"flip y",OP_PORT_TYPE_VALUE,{display:"bool"})),this.multiply.set(1),this.smoothSpeed.set(20);var g,c=this.smoothSpeed.get(),P=null;this.smooth.onValueChanged=function(){s.smooth.get()?g=setInterval(t,15):clearTimeout(g)};var T=0,h=0,m=l.canvas.width/2,p=l.canvas.height/2;T=m,h=p,this.mouseX.set(m),this.mouseY.set(p);var v=0,E=0,_=0,O=0;i(),f.onValueChanged=i;var x=function(e){s.mouseDown.set(!1),s.mouseOver.set(!0),c=s.smoothSpeed.get()},C=function(e){u.set(e.which),s.mouseDown.set(!0)},R=function(e){u.set(0),s.mouseDown.set(!1),s.mouseClick.set(!1),d.trigger()},w=function(e){s.mouseClickRight.trigger(),e.preventDefault()};this.relative.onValueChanged=function(){_=0,O=0};var L=function(t){s.mouseOver.set(!0),s.relative.get()?(0!=v&&0!=E&&(_=t.offsetX-v,O=t.offsetY-E),v=t.offsetX,E=t.offsetY,m+=_,p+=O,p>460&&(p=460)):("Canvas"==f.get()?(_=t.offsetX,O=t.offsetY):(_=t.clientX,O=t.clientY),s.smooth.get()?(m=_,p=s.flipY.get()?P.clientHeight-O:O):s.flipY.get()?e(_,P.clientHeight-O):e(_,O))};this.onDelete=function(){console.log("remove mouse op..."),o()},i()},Ops.Devices.Mouse.Mouse.prototype=new CABLES.Op,Ops.Gl.Meshes.Cube=function(){function e(){f||(f=new CGL.Geometry);var e=parseFloat(r.get()),t=-1*parseFloat(r.get()),n=parseFloat(o.get()),s=-1*parseFloat(o.get()),g=parseFloat(i.get()),c=-1*parseFloat(i.get());a.get()||(t=0,s=0,c=0),f.vertices=[t,s,g,e,s,g,e,n,g,t,n,g,t,s,c,t,n,c,e,n,c,e,s,c,t,n,c,t,n,g,e,n,g,e,n,c,t,s,c,e,s,c,e,s,g,t,s,g,e,s,c,e,n,c,e,n,g,e,s,g,t,s,c,t,s,g,t,n,g,t,n,c],f.texCoords=[0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1],f.vertexNormals=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0],f.verticesIndices=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],u=new CGL.Mesh(d,f),l.set(null),l.set(f)}Op.apply(this,arguments);var t=this;t.name="Cube";var n=t.inFunction("render"),r=t.inValue("width"),o=t.inValue("height"),i=t.inValue("length"),a=t.inValueBool("center"),s=t.outFunction("trigger"),l=t.outObject("geometry");l.ignoreValueSerialize=!0;var d=t.patch.cgl,f=null,u=null;r.set(1),o.set(1),i.set(1),a.set(!0),n.onTriggered=function(){u&&u.render(d.getShader()),s.trigger()},r.onValueChanged=e,o.onValueChanged=e,i.onValueChanged=e,a.onValueChanged=e,e()},Ops.Gl.Meshes.Cube.prototype=new CABLES.Op,Ops.Anim.RelativeTime=function(){function e(){o.set(t.patch.freeTimer.get()*r.get())}Op.apply(this,arguments);var t=this;t.name="RelativeTime";var n=t.inFunction("exe"),r=t.inValue("Multiply",1),o=t.outValue("result");n.onTriggered=e,e()},Ops.Anim.RelativeTime.prototype=new CABLES.Op,Ops.Gl.MainLoop=function(){Op.apply(this,arguments);var e=this;e.name="MainLoop";var t=e.inValue("FPS Limit",0),n=e.outFunction("trigger"),r=e.outValue("width"),o=e.outValue("height"),i=(e.inValueBool("Reduce FPS loading"),e.patch.cgl),a=0,s=0;e.patch.cgl||e.uiAttr({error:"No webgl cgl context"});var l=vec3.create();vec3.set(l,0,0,0);var d=vec3.create();vec3.set(d,0,0,-2),t.onChange=function(){e.patch.config.fpsLimit=t.get()||0},e.onDelete=function(){i.gl.clearColor(0,0,0,0),i.gl.clear(i.gl.COLOR_BUFFER_BIT|i.gl.DEPTH_BUFFER_BIT),e.patch.removeOnAnimFrame(e)},e.patch.loading.setOnFinishedLoading(function(n){e.patch.config.fpsLimit=t.get()}),e.onAnimFrame=function(t){if(!i.aborted&&0!==i.canvas.clientWidth&&0!==i.canvas.clientHeight){if(e.patch.loading.getProgress()<1&&(e.patch.config.fpsLimit=5),-1==i.canvasWidth)return void i.setCanvas(e.patch.config.glCanvasId);(i.canvasWidth!=i.canvas.clientWidth||i.canvasHeight!=i.canvas.clientHeight)&&(i.canvasWidth=i.canvas.clientWidth,r.set(i.canvasWidth),i.canvasHeight=i.canvas.clientHeight,o.set(i.canvasHeight)),CABLES.milliSeconds()-s>1e3&&(CGL.fpsReport=CGL.fpsReport||[],e.patch.loading.getProgress()>=1&&0!==s&&CGL.fpsReport.push(a),a=0,s=CABLES.milliSeconds()),CGL.MESH.lastShader=null,CGL.MESH.lastMesh=null,i.renderStart(i,l,d),n.trigger(),CGL.MESH.lastMesh&&CGL.MESH.lastMesh.unBind(),CGL.Texture.previewTexture&&(CGL.Texture.texturePreviewer||(CGL.Texture.texturePreviewer=new CGL.Texture.texturePreview(i)),CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture)),i.renderEnd(i),i.frameStore.phong||(i.frameStore.phong={}),a++}}},Ops.Gl.MainLoop.prototype=new CABLES.Op,Ops.Gl.Meshes.Sphere=function(){function e(){var e=Math.round(a.get()),t=Math.round(i.get());1>e&&(e=1),1>t&&(t=1);var r=s.get();n(r,e,t)}function t(e,t){var n,r=Math.abs(e),o=(t?1:2)*Math.PI/e,i=[],a=[];for(i[0]=0,a[0]=1,n=0;r>n;n++)i[n]=Math.sin(o*n),a[n]=Math.cos(o*n);return t?(i[r]=0,a[r]=-1):(i[r]=i[0],a[r]=a[0]),{cost:a,sint:i}}function n(e,n,r){var o,i,a,s,l,g=0,c=new CGL.Geometry("sphere"),P=t(-n,!1),T=t(r,!0);for(c.vertices=[],c.vertexNormals=[],c.texCoords=[],c.vertices[0]=0,c.vertices[1]=0,c.vertices[2]=e,c.vertexNormals[0]=0,c.vertexNormals[1]=0,c.vertexNormals[2]=1,c.texCoords[0]=0,c.texCoords[1]=0,g=3,o=1;r>o;o++)for(i=0;n>=i;i++,g+=3)a=P.cost[i]*T.sint[o],s=P.sint[i]*T.sint[o],l=T.cost[o],c.vertices[g]=a*e,c.vertices[g+1]=s*e,c.vertices[g+2]=l*e,c.vertexNormals[g]=a,c.vertexNormals[g+1]=s,c.vertexNormals[g+2]=l,c.texCoords[g/3*2]=i/n,c.texCoords[g/3*2+1]=(o-1)/(r-2);c.vertices[g]=0,c.vertices[g+1]=0,c.vertices[g+2]=-e,c.vertexNormals[g]=0,c.vertexNormals[g+1]=0,c.vertexNormals[g+2]=-1,c.texCoords[(g+3)/3*2]=1,c.texCoords[(g+3)/3*2+1]=1;var h=0;for(i=0,g=0;n>=i;i++,g+=2)c.verticesIndices[g]=i+1,c.verticesIndices[g+1]=0;c.verticesIndices[g]=1,c.verticesIndices[g+1]=0;var m=c.vertices.length/3;for(o=0;r-1>o;o++,g+=2){for(h=1+o*n,i=0;n>i;i++,g+=2)c.verticesIndices[g]=h+i+n,c.verticesIndices[g+1]=h+i;c.verticesIndices[g]=h+n,c.verticesIndices[g+1]=h}for(h=1+(r-2)*n,i=0;n>i;i++,g+=2)c.verticesIndices[g]=m-1,c.verticesIndices[g+1]=h+i;c.verticesIndices[g]=m-1,c.verticesIndices[g+1]=h,d.set(c),u=new CGL.Mesh(f,c,f.gl.TRIANGLE_STRIP)}Op.apply(this,arguments);var r=this;r.name="Sphere";var o=r.addInPort(new Port(r,"render",OP_PORT_TYPE_FUNCTION)),i=r.addInPort(new Port(r,"stacks",OP_PORT_TYPE_VALUE)),a=r.addInPort(new Port(r,"slices",OP_PORT_TYPE_VALUE)),s=r.addInPort(new Port(r,"radius",OP_PORT_TYPE_VALUE)),l=r.addOutPort(new Port(r,"trigger",OP_PORT_TYPE_FUNCTION)),d=r.addOutPort(new Port(r,"geometry",OP_PORT_TYPE_OBJECT));i.set(16),a.set(16),s.set(1),d.ignoreValueSerialize=!0;var f=r.patch.cgl,u=null;a.onValueChanged=function(){u=null},i.onValueChanged=function(){u=null},s.onValueChanged=function(){u=null},o.onTriggered=function(){null!==u?u.render(f.getShader()):e(),l.trigger()}},Ops.Gl.Meshes.Sphere.prototype=new CABLES.Op;